<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Asset Deviation Tracker (Multiple Instances, No Defaults)</title>
  <!-- Make pages scale nicely on phones -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- jsPDF from CDN for PDF generation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    /* Global styling with gradient background and emojis */
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      max-width: 1000px;
      margin-left: auto;
      margin-right: auto;
      background: linear-gradient(to bottom right, #f0f0f0, #ffffff);
    }
    /* Add an emoji before the title */
    h1:before {
      content: "üì∏ ";
    }
    h1, h2 {
      text-align: center;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    form, .buttons {
      margin: 20px 0;
      text-align: center;
    }
    label {
      display: block;
      margin: 5px 0 2px;
      font-weight: bold;
    }
    select, input, button, textarea {
      margin: 5px 0;
      width: 100%;
      box-sizing: border-box;
      font-size: 1rem;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    textarea {
      resize: vertical;
    }
    button {
      cursor: pointer;
      border: none;
      background-color: #0078d7;
      color: white;
      padding: 8px 12px;
      font-size: 1rem;
      border-radius: 4px;
      margin: 5px;
    }
    button:hover {
      background-color: #005fab;
    }
    /* Table styling */
    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 20px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      border-radius: 4px;
      overflow: hidden;
    }
    table thead tr {
      background-color: #f7f7f7;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 10px;
      vertical-align: top;
    }
    th {
      background: #f9f9f9;
    }
    /* Emoji icons in table headers */
    th:nth-child(1)::before { content: "üî¢ "; }
    th:nth-child(2)::before { content: "üì∏ "; }
    th:nth-child(3)::before { content: "‚ùó "; }
    th:nth-child(4)::before { content: "üõ†Ô∏è "; }
    th:nth-child(5)::before { content: "‚ö†Ô∏è "; }
    /* Hover effect for table rows */
    tbody tr:hover {
      background-color: #fafafa;
    }
    img {
      max-width: 120px;
      height: auto;
      display: block;
      margin: 0 auto;
    }
    /* Responsive table for smaller screens */
    @media (max-width: 600px) {
      table, thead, tbody, th, td, tr {
        display: block;
        width: 100%;
      }
      thead {
        display: none;
      }
      tr {
        margin-bottom: 20px;
        border: 1px solid #ccc;
      }
      td {
        border: none;
        padding: 5px 0;
      }
      td:before {
        content: attr(data-label);
        font-weight: bold;
        display: block;
      }
      img {
        max-width: 80px;
      }
    }
  </style>
</head>
<body>
  <h1>Asset Deviation Tracker</h1>

  <!-- 1) INSTANCE SELECTION -->
  <div style="text-align:center; margin-bottom: 15px;">
    <label for="instanceSelect">Select or Create an Instance:</label>
    <select id="instanceSelect">
      <!-- Initially empty; we'll load from the meta store -->
    </select>
    <!-- Input for a custom instance name -->
    <input type="text" id="newInstanceInput" placeholder="New Instance Name" style="width:auto; display:inline-block;" />
    <button id="addInstanceBtn">Add Instance</button>
    <!-- Button to delete the currently selected instance -->
    <button id="deleteInstanceBtn" style="background-color: #d9534f;">Delete Instance</button>
  </div>
  
  <!-- Asset Code input with datalist -->
  <label for="searchCodeInput">Asset Code (Search or type custom):</label>
  <input type="text" id="searchCodeInput" placeholder="e.g. 131-CON-01..." list="codeSuggestions" />
  <datalist id="codeSuggestions"></datalist>

  <!-- The Add Entry form -->
  <form id="entryForm">
    <label for="imageInput">Photo:</label>
    <input type="file" id="imageInput" accept="image/*;capture=camera" required>
    
    <label for="deviationInput">Deviation:</label>
    <textarea id="deviationInput" rows="2" placeholder="Describe the deviation" required></textarea>
    
    <label for="criticalityInput">Criticality:</label>
    <select id="criticalityInput" required>
      <option value="">Select Criticality</option>
      <option value="Low">Low</option>
      <option value="Medium">Medium</option>
      <option value="High">High</option>
    </select>
    
    <label for="remedialInput">Remedial Action:</label>
    <textarea id="remedialInput" rows="2" placeholder="e.g. Fix, Replace" required></textarea>
    <button type="submit">Add Entry</button>
  </form>

  <div class="buttons">
    <!-- PDF Orientation Selector -->
    <label for="pdfOrientation">PDF Orientation:</label>
    <select id="pdfOrientation">
      <option value="l">Landscape</option>
      <option value="p">Portrait</option>
    </select>
    <button id="generatePdf">Generate PDF</button>
    <button id="exportCsv">Export CSV</button>
    <button id="clearAll">Clear All Entries</button>
  </div>

  <h2>Existing Entries</h2>
  <table id="entriesTable">
    <thead>
      <tr>
        <th>Asset Code</th>
        <th>Photo</th>
        <th>Deviation</th>
        <th>Remedial Action</th>
        <th>Criticality</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    ////////////////////////////////////////////////////////////////////////////
    // GLOBALS
    ////////////////////////////////////////////////////////////////////////////
    let db;                    // The IndexedDB handle
    let entries = [];          // In-memory array for the current instance's entries
    let currentInstance = "";  // No default instance

    // Database name & version
    // IMPORTANT: If you previously used version=1, bump this so onupgradeneeded is triggered.
    const DB_NAME = 'DeviationsDB_Multi';
    const DB_VERSION = 2;

    // We'll store the instance names in a "meta" store named "__knownStores"
    const META_STORE = '__knownStores';

    // For asset code suggestions (optional if you have an assetCodes.txt)
    let allCodes = [];

    ////////////////////////////////////////////////////////////////////////////
    // DOM Elements
    ////////////////////////////////////////////////////////////////////////////
    const instanceSelect      = document.getElementById('instanceSelect');
    const newInstanceInput    = document.getElementById('newInstanceInput');
    const addInstanceBtn      = document.getElementById('addInstanceBtn');
    const deleteInstanceBtn   = document.getElementById('deleteInstanceBtn');

    const searchCodeInput     = document.getElementById('searchCodeInput');
    const codeSuggestions     = document.getElementById('codeSuggestions');
    const entryForm           = document.getElementById('entryForm');
    const imageInput          = document.getElementById('imageInput');
    const deviationInput      = document.getElementById('deviationInput');
    const criticalityInput    = document.getElementById('criticalityInput');
    const remedialInput       = document.getElementById('remedialInput');
    const entriesTableBody    = document.querySelector('#entriesTable tbody');
    const generatePdfButton   = document.getElementById('generatePdf');
    const clearAllButton      = document.getElementById('clearAll');
    const pdfOrientationSelect= document.getElementById('pdfOrientation');

    ////////////////////////////////////////////////////////////////////////////
    // 1) OPEN or UPGRADE THE DATABASE (async)
    ////////////////////////////////////////////////////////////////////////////
    async function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = event => {
          console.error("Database error:", event.target.error);
          reject(event.target.error);
        };
        request.onupgradeneeded = event => {
          db = event.target.result;
          // Create meta store if needed
          if (!db.objectStoreNames.contains(META_STORE)) {
            db.createObjectStore(META_STORE, { keyPath: 'name' });
          }
        };
        request.onsuccess = event => {
          db = event.target.result;
          resolve(db);
        };
      });
    }

    ////////////////////////////////////////////////////////////////////////////
    // 2) CREATE a store for the CURRENT instance if it doesn't exist
    ////////////////////////////////////////////////////////////////////////////
    function ensureStoreExists(storeName) {
      return new Promise((resolve, reject) => {
        if (!storeName) return resolve();  // no instance => do nothing
        if (db.objectStoreNames.contains(storeName)) {
          // Already exists
          return resolve();
        }
        // If store doesn't exist, we must close DB and open with new version
        db.close();
        const req = indexedDB.open(DB_NAME, db.version + 1);
        req.onupgradeneeded = event => {
          const upgradeDB = event.target.result;
          // Make sure meta store also exists
          if (!upgradeDB.objectStoreNames.contains(META_STORE)) {
            upgradeDB.createObjectStore(META_STORE, { keyPath: 'name' });
          }
          if (!upgradeDB.objectStoreNames.contains(storeName)) {
            upgradeDB.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true });
          }
        };
        req.onsuccess = event => {
          db = event.target.result; // reassign global db
          resolve();
        };
        req.onerror = event => reject(event.target.error);
      });
    }

    ////////////////////////////////////////////////////////////////////////////
    // 3) DELETE the entire store for a given instance
    ////////////////////////////////////////////////////////////////////////////
    function deleteInstanceStore(storeName) {
      return new Promise((resolve, reject) => {
        if (!db.objectStoreNames.contains(storeName)) {
          // If it doesn't exist, nothing to delete
          return resolve();
        }
        db.close();
        const req = indexedDB.open(DB_NAME, db.version + 1);
        req.onupgradeneeded = event => {
          const upgradeDB = event.target.result;
          if (upgradeDB.objectStoreNames.contains(storeName)) {
            upgradeDB.deleteObjectStore(storeName);
          }
        };
        req.onsuccess = event => {
          db = event.target.result;
          resolve();
        };
        req.onerror = event => reject(event.target.error);
      });
    }

    ////////////////////////////////////////////////////////////////////////////
    // 4) Store-level CRUD (getAll, add, update, delete, clear)
    ////////////////////////////////////////////////////////////////////////////
    function getAllEntries(storeName) {
      return new Promise((resolve, reject) => {
        if (!storeName) return resolve([]); 
        const tx = db.transaction([storeName], 'readonly');
        const store = tx.objectStore(storeName);
        const req = store.getAll();
        req.onsuccess = e => resolve(e.target.result);
        req.onerror = e => reject(e.target.error);
      });
    }

    function addEntry(storeName, entry) {
      return new Promise((resolve, reject) => {
        if (!storeName) return reject("No instance selected");
        const tx = db.transaction([storeName], 'readwrite');
        const store = tx.objectStore(storeName);
        const req = store.add(entry);
        req.onsuccess = e => {
          entry.id = e.target.result;
          resolve(entry);
        };
        req.onerror = e => reject(e.target.error);
      });
    }

    function updateEntry(storeName, entry) {
      return new Promise((resolve, reject) => {
        if (!storeName) return reject("No instance selected");
        const tx = db.transaction([storeName], 'readwrite');
        const store = tx.objectStore(storeName);
        const req = store.put(entry);
        req.onsuccess = () => resolve();
        req.onerror = e => reject(e.target.error);
      });
    }

    function removeEntry(storeName, id) {
      return new Promise((resolve, reject) => {
        if (!storeName) return reject("No instance selected");
        const tx = db.transaction([storeName], 'readwrite');
        const store = tx.objectStore(storeName);
        const req = store.delete(id);
        req.onsuccess = () => resolve();
        req.onerror = e => reject(e.target.error);
      });
    }

    function clearAllEntries(storeName) {
      return new Promise((resolve, reject) => {
        if (!storeName) return reject("No instance selected");
        const tx = db.transaction([storeName], 'readwrite');
        const store = tx.objectStore(storeName);
        const req = store.clear();
        req.onsuccess = () => resolve();
        req.onerror = e => reject(e.target.error);
      });
    }

    ////////////////////////////////////////////////////////////////////////////
    // 5) REFRESH the in-memory array from the current instance store, then render
    ////////////////////////////////////////////////////////////////////////////
    async function refreshEntries() {
      try {
        if (!currentInstance) {
          entries = [];
          renderEntries();
          return;
        }
        await ensureStoreExists(currentInstance);
        entries = await getAllEntries(currentInstance);
        renderEntries();
      } catch (err) {
        console.error("Error refreshing entries:", err);
      }
    }

    ////////////////////////////////////////////////////////////////////////////
    // 6) RENDER the table
    ////////////////////////////////////////////////////////////////////////////
    function renderEntries() {
      entriesTableBody.innerHTML = '';
      if (!currentInstance) {
        return; // no instance => empty table
      }

      const filterText = searchCodeInput.value.trim().toLowerCase();
      let rowsToShow = filterText
        ? entries.filter(e => e.assetCode.toLowerCase().includes(filterText))
        : entries;
      // Limit to 50 for performance
      rowsToShow = rowsToShow.slice(0, 50);

      rowsToShow.forEach(entry => {
        const tr = document.createElement('tr');

        // Asset Code
        const tdAsset = document.createElement('td');
        tdAsset.setAttribute('data-label', 'Asset Code');
        const assetArea = document.createElement('textarea');
        assetArea.value = entry.assetCode;
        assetArea.rows = 1;
        assetArea.style.width = '100%';
        assetArea.oninput = () => {
          entry.assetCode = assetArea.value;
          updateEntry(currentInstance, entry).catch(err => console.error("Error updating entry:", err));
        };
        tdAsset.appendChild(assetArea);
        tr.appendChild(tdAsset);

        // Photo
        const tdPhoto = document.createElement('td');
        tdPhoto.setAttribute('data-label', 'Photo');
        const img = document.createElement('img');
        img.src = entry.image;
        tdPhoto.appendChild(img);
        tr.appendChild(tdPhoto);

        // Deviation
        const tdDeviation = document.createElement('td');
        tdDeviation.setAttribute('data-label', 'Deviation');
        const devArea = document.createElement('textarea');
        devArea.value = entry.deviation;
        devArea.rows = 2;
        devArea.style.width = '100%';
        devArea.oninput = () => {
          entry.deviation = devArea.value;
          updateEntry(currentInstance, entry).catch(err => console.error("Error updating entry:", err));
        };
        tdDeviation.appendChild(devArea);
        tr.appendChild(tdDeviation);

        // Remedial
        const tdRemedial = document.createElement('td');
        tdRemedial.setAttribute('data-label', 'Remedial Action');
        const remArea = document.createElement('textarea');
        remArea.value = entry.remedial;
        remArea.rows = 2;
        remArea.style.width = '100%';
        remArea.oninput = () => {
          entry.remedial = remArea.value;
          updateEntry(currentInstance, entry).catch(err => console.error("Error updating entry:", err));
        };
        tdRemedial.appendChild(remArea);
        tr.appendChild(tdRemedial);

        // Criticality
        const tdCriticality = document.createElement('td');
        tdCriticality.setAttribute('data-label', 'Criticality');
        const critArea = document.createElement('textarea');
        critArea.value = entry.criticality;
        critArea.rows = 1;
        critArea.style.width = '100%';
        critArea.oninput = () => {
          entry.criticality = critArea.value;
          updateEntry(currentInstance, entry).catch(err => console.error("Error updating entry:", err));
        };
        tdCriticality.appendChild(critArea);
        tr.appendChild(tdCriticality);

        // Actions
        const tdActions = document.createElement('td');
        tdActions.setAttribute('data-label', 'Actions');
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.onclick = () => {
          if (confirm("Are you sure you want to delete this entry?")) {
            removeEntry(currentInstance, entry.id)
              .then(() => refreshEntries())
              .catch(err => console.error("Error deleting entry:", err));
          }
        };
        tdActions.appendChild(deleteBtn);
        tr.appendChild(tdActions);

        entriesTableBody.appendChild(tr);
      });
    }

    ////////////////////////////////////////////////////////////////////////////
    // 7) DEBOUNCE for filtering & code suggestions
    ////////////////////////////////////////////////////////////////////////////
    function debounce(fn, delay) {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn(...args), delay);
      };
    }

    const handleSearch = debounce(() => {
      updateCodeSuggestions();
      renderEntries();
    }, 800);
    searchCodeInput.addEventListener('input', handleSearch);

    ////////////////////////////////////////////////////////////////////////////
    // 8) Optional: Load Asset Codes from assetCodes.txt
    ////////////////////////////////////////////////////////////////////////////
    fetch('assetCodes.txt')
      .then(res => {
        if (!res.ok) throw new Error('Could not load assetCodes.txt');
        return res.text();
      })
      .then(data => {
        allCodes = data.split('\n').map(line => line.trim()).filter(line => line !== '');
      })
      .catch(err => console.error(err));

    function updateCodeSuggestions() {
      codeSuggestions.innerHTML = '';
      const typed = searchCodeInput.value.trim().toLowerCase();
      let matched = typed
        ? allCodes.filter(code => code.toLowerCase().includes(typed))
        : allCodes;
      const MAX_SUGGESTIONS = 50;
      matched.slice(0, MAX_SUGGESTIONS).forEach(code => {
        const opt = document.createElement('option');
        opt.value = code;
        codeSuggestions.appendChild(opt);
      });
    }

    ////////////////////////////////////////////////////////////////////////////
    // 9) ADD NEW ENTRY
    ////////////////////////////////////////////////////////////////////////////
    entryForm.addEventListener('submit', e => {
      e.preventDefault();
      if (!currentInstance) {
        alert("Please create or select an instance first.");
        return;
      }
      const code       = searchCodeInput.value.trim();
      const file       = imageInput.files[0];
      const deviation  = deviationInput.value.trim();
      const criticality= criticalityInput.value.trim();
      const remedial   = remedialInput.value.trim();

      if (!code) {
        alert('Please type or pick an Asset Code before adding an entry.');
        return;
      }
      if (!file) {
        alert('Please select a photo.');
        return;
      }
      if (!deviation || !criticality || !remedial) {
        alert('Fill out all fields (Deviation, Criticality, Remedial).');
        return;
      }

      const reader = new FileReader();
      reader.onload = async function(evt) {
        const imageData = evt.target.result;
        const newEntry = {
          assetCode: code,
          image: imageData,
          deviation: deviation,
          remedial: remedial,
          criticality: criticality,
          timestamp: Date.now()
        };
        try {
          await addEntry(currentInstance, newEntry);
          // Clear form
          imageInput.value = '';
          deviationInput.value = '';
          criticalityInput.value = '';
          remedialInput.value = '';
          // Refresh
          await refreshEntries();
        } catch(err) {
          console.error("Error adding entry:", err);
          alert("Failed to add entry. Check console for details.");
        }
      };
      reader.readAsDataURL(file);
    });

    ////////////////////////////////////////////////////////////////////////////
    // 10) CLEAR ALL from the current instance
    ////////////////////////////////////////////////////////////////////////////
    clearAllButton.addEventListener('click', async () => {
      if (!currentInstance) {
        alert("No instance selected.");
        return;
      }
      if (!entries.length) {
        alert("No entries to clear in this instance.");
        return;
      }
      if (confirm(`Are you sure you want to clear all entries in "${currentInstance}"? This cannot be undone.`)) {
        try {
          await clearAllEntries(currentInstance);
          refreshEntries();
        } catch (err) {
          console.error("Error clearing entries:", err);
          alert("Error clearing entries. Check console for details.");
        }
      }
    });

    ////////////////////////////////////////////////////////////////////////////
    // 11) GENERATE PDF for the current instance
    ////////////////////////////////////////////////////////////////////////////
    generatePdfButton.addEventListener('click', () => {
      if (!currentInstance) {
        alert("No instance selected.");
        return;
      }
      const { jsPDF } = window.jspdf;
      const orientation = pdfOrientationSelect.value; // 'l' or 'p'
      const doc = new jsPDF(orientation, 'pt', 'letter');
      const pageWidth  = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const margin  = 40;
      const startX  = margin;
      let currentY  = margin;

      doc.setFontSize(14);
      doc.text(`Deviation Table - Instance: ${currentInstance}`, startX, currentY);
      currentY += 20;

      const filterText = searchCodeInput.value.trim().toLowerCase();
      const pdfEntries = filterText
        ? entries.filter(e => e.assetCode.toLowerCase().includes(filterText))
        : entries;

      pdfEntries.forEach((entry, idx) => {
        if (currentY > pageHeight - margin - 120) {
          doc.addPage();
          currentY = margin;
        }
        doc.setFontSize(12);
        doc.text(`(${idx + 1}) Asset Code: ${entry.assetCode}`, startX, currentY);
        currentY += 14;
        doc.text(`Deviation: ${entry.deviation}`, startX, currentY);
        currentY += 14;
        doc.text(`Remedial: ${entry.remedial}`, startX, currentY);
        currentY += 14;
        doc.text(`Criticality: ${entry.criticality}`, startX, currentY);
        currentY += 14;

        try {
          const isPng = (entry.image || '').toLowerCase().includes('image/png');
          const format = isPng ? 'PNG' : 'JPEG';
          const props = doc.getImageProperties(entry.image);
          const maxImgW = 200;
          const maxImgH = 120;
          let iWidth  = props.width;
          let iHeight = props.height;
          const ratio = Math.min(maxImgW / iWidth, maxImgH / iHeight);
          iWidth  *= ratio;
          iHeight *= ratio;
          doc.addImage(entry.image, format, startX, currentY, iWidth, iHeight);
          currentY += iHeight + 10;
        } catch (err) {
          currentY += 10;
          console.error("Image error:", err);
        }
        currentY += 10;
      });

      doc.save(`deviation_tracker_${currentInstance}.pdf`);
    });

    ////////////////////////////////////////////////////////////////////////////
    // 12) META STORE FOR PERSISTING INSTANCE NAMES
    ////////////////////////////////////////////////////////////////////////////
    async function addInstanceName(name) {
      const all = await getAllInstanceNames();
      // Only add if not already in the list
      if (all.find(item => item.name === name)) return;
      return new Promise((resolve, reject) => {
        const tx = db.transaction([META_STORE], 'readwrite');
        const store = tx.objectStore(META_STORE);
        store.add({ name });
        tx.oncomplete = () => resolve();
        tx.onerror = e => reject(e.target.error);
      });
    }

    async function removeInstanceName(name) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction([META_STORE], 'readwrite');
        const store = tx.objectStore(META_STORE);
        store.delete(name);
        tx.oncomplete = () => resolve();
        tx.onerror = e => reject(e.target.error);
      });
    }

    async function getAllInstanceNames() {
      return new Promise((resolve, reject) => {
        const tx = db.transaction([META_STORE], 'readonly');
        const store = tx.objectStore(META_STORE);
        const req = store.getAll();
        req.onsuccess = e => resolve(e.target.result);
        req.onerror = e => reject(e.target.error);
      });
    }

    // Reload the dropdown from the meta store
    async function loadInstanceList() {
      const all = await getAllInstanceNames();
      instanceSelect.innerHTML = ''; // Clear out old
      all.forEach(item => {
        const opt = document.createElement('option');
        opt.value = item.name;
        opt.textContent = item.name;
        instanceSelect.appendChild(opt);
      });
      // If currentInstance is missing, reset it
      if (currentInstance && !all.find(i => i.name === currentInstance)) {
        currentInstance = '';
      }
      // If no current instance but we have at least one, pick the first
      if (!currentInstance && all.length > 0) {
        currentInstance = all[0].name;
        instanceSelect.value = currentInstance;
      }
    }

    ////////////////////////////////////////////////////////////////////////////
    // 13) MULTI-INSTANCE UI
    ////////////////////////////////////////////////////////////////////////////
    instanceSelect.addEventListener('change', async () => {
      currentInstance = instanceSelect.value;
      await refreshEntries();
    });

    addInstanceBtn.addEventListener('click', async () => {
      const name = newInstanceInput.value.trim();
      if (!name) {
        alert("Enter a valid instance name.");
        return;
      }
      try {
        // Store the name in the meta store
        await addInstanceName(name);
        // Ensure the store is created
        await ensureStoreExists(name);
        // Reload the list and select the new instance
        await loadInstanceList();
        instanceSelect.value = name;
        currentInstance = name;
        newInstanceInput.value = '';
        // Now load data
        await refreshEntries();
      } catch (err) {
        console.error("Error adding instance:", err);
        alert("Could not create instance. Check console for details.");
      }
    });

    deleteInstanceBtn.addEventListener('click', async () => {
      const storeName = instanceSelect.value;
      if (!storeName) {
        alert("No instance is selected.");
        return;
      }
      if (!confirm(`Are you sure you want to delete instance "${storeName}"? All data will be lost.`)) {
        return;
      }
      try {
        // Remove from meta store
        await removeInstanceName(storeName);
        // Delete the actual object store
        await deleteInstanceStore(storeName);
        // Reload the list
        await loadInstanceList();
        // Refresh the table
        await refreshEntries();
        alert(`Instance "${storeName}" has been deleted.`);
      } catch (err) {
        console.error("Error deleting instance store:", err);
        alert("Could not delete instance. Check console for details.");
      }
    });

    ////////////////////////////////////////////////////////////////////////////
    // 14) ON PAGE LOAD, OPEN DB, LOAD INSTANCE LIST, REFRESH
    ////////////////////////////////////////////////////////////////////////////
    window.addEventListener('DOMContentLoaded', async () => {
      try {
        // 1) Open DB
        await openDatabase();

        // 2) Load known instance names
        await loadInstanceList();

        // 3) If there's a selected instance, refresh to show its data
        await refreshEntries();
      } catch (err) {
        console.error("Failed to open DB:", err);
        alert("Could not open IndexedDB. Make sure you're not in incognito or using file://");
      }
    });
  </script>
</body>
</html>
