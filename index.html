<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Non-conformance Tracker</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f8f9fa;
    }
    h1 { text-align: center; color: #2c3e50; }
    .controls { margin: 20px 0; }
    input, select, textarea, button {
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
    }
    button {
      background: #3498db;
      color: white;
      border: none;
      cursor: pointer;
    }
    button:hover { background: #2980b9; }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 10px;
      text-align: left;
    }
    img { max-width: 150px; height: auto; }
    .criticality-low { color: #27ae60; }
    .criticality-medium { color: #f1c40f; }
    .criticality-high { color: #e74c3c; }
    .orientation-selector { margin: 10px 0; }
    .orientation-btn {
      padding: 8px 15px;
      margin-right: 10px;
      background: #ecf0f1;
      border: 1px solid #bdc3c7;
      cursor: pointer;
    }
    .orientation-btn.active { background: #3498db; color: white; }
    @media (max-width: 768px) {
      table, thead, tbody, th, td, tr { display: block; }
      thead { display: none; }
      td { border: none; position: relative; padding-left: 50%; }
      td::before {
        content: attr(data-label);
        position: absolute;
        left: 10px;
        font-weight: bold;
      }
      img { max-width: 100px; }
    }
  </style>
</head>
<body>
  <h1>Non-conformance Tracker</h1>

  <div class="orientation-selector">
    <button class="orientation-btn active" data-orientation="portrait">Portrait</button>
    <button class="orientation-btn" data-orientation="landscape">Landscape</button>
  </div>

  <div class="controls">
    <input type="text" id="searchInput" placeholder="Search asset code..." list="assetCodes">
    <datalist id="assetCodes"></datalist>
  </div>

  <form id="entryForm">
    <input type="file" id="imageInput" accept="image/*" required>
    <textarea id="nonConformance" placeholder="Non-conformance description..." required></textarea>
    <select id="criticality" required>
      <option value="low">Low</option>
      <option value="medium">Medium</option>
      <option value="high">High</option>
    </select>
    <textarea id="remedial" placeholder="Remedial action..." required></textarea>
    <button type="submit">Add Entry</button>
  </form>

  <table id="entriesTable">
    <thead>
      <tr>
        <th>Asset Code</th>
        <th>Photo</th>
        <th>Non-conformance</th>
        <th>Criticality</th>
        <th>Remedial Action</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
  <script>
    const DB_NAME = 'NCRTrackerDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'entries';
    let db;
    let entries = [];
    let pdfOrientation = 'portrait';

    // Database initialization
    async function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
          }
        };
        request.onsuccess = (event) => {
          db = event.target.result;
          resolve();
        };
      });
    }

    // Entry management
    async function loadEntries() {
      return new Promise((resolve) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        store.getAll().onsuccess = (event) => {
          entries = event.target.result;
          resolve();
        };
      });
    }

    async function saveEntry(entry) {
      return new Promise((resolve) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = entry.id ? store.put(entry) : store.add(entry);
        request.onsuccess = () => {
          entry.id = request.result;
          resolve();
        };
      });
    }

    async function deleteEntry(id) {
      return new Promise((resolve) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        transaction.objectStore(STORE_NAME).delete(id).onsuccess = resolve;
      });
    }

    // Image handling
    async function compressImage(file) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (event) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement('canvas');
            const maxSize = 800;
            let width = img.width;
            let height = img.height;

            if (width > height) {
              if (width > maxSize) {
                height *= maxSize / width;
                width = maxSize;
              }
            } else {
              if (height > maxSize) {
                width *= maxSize / height;
                height = maxSize;
              }
            }

            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            resolve(canvas.toDataURL('image/jpeg', 0.8));
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      });
    }

    // UI rendering
    function renderEntries() {
      const searchTerm = document.getElementById('searchInput').value.toLowerCase();
      const filtered = entries.filter(entry => 
        entry.assetCode.toLowerCase().includes(searchTerm)
      );

      const tbody = document.querySelector('#entriesTable tbody');
      tbody.innerHTML = filtered.map(entry => `
        <tr>
          <td data-label="Asset Code"><input type="text" value="${entry.assetCode}"></td>
          <td data-label="Photo"><img src="${entry.image}"></td>
          <td data-label="Non-conformance"><textarea>${entry.nonConformance}</textarea></td>
          <td data-label="Criticality" class="criticality-${entry.criticality}">
            <select class="criticality-select">
              <option ${entry.criticality === 'low' ? 'selected' : ''}>Low</option>
              <option ${entry.criticality === 'medium' ? 'selected' : ''}>Medium</option>
              <option ${entry.criticality === 'high' ? 'selected' : ''}>High</option>
            </select>
          </td>
          <td data-label="Remedial Action"><textarea>${entry.remedial}</textarea></td>
          <td data-label="Actions">
            <button onclick="deleteItem(${entry.id})">Delete</button>
          </td>
        </tr>
      `).join('');

      // Update asset code suggestions
      const assetCodes = [...new Set(entries.map(e => e.assetCode))];
      document.getElementById('assetCodes').innerHTML = 
        assetCodes.map(code => `<option value="${code}">`).join('');
    }

    // PDF Generation
    async function generatePDF() {
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({
        orientation: pdfOrientation,
        unit: 'pt',
        format: 'letter'
      });

      const columns = [
        { header: 'Asset Code', dataKey: 'assetCode' },
        { header: 'Non-conformance', dataKey: 'nonConformance' },
        { header: 'Criticality', dataKey: 'criticality' },
        { header: 'Remedial Action', dataKey: 'remedial' },
        { header: 'Photo', dataKey: 'image' }
      ];

      const data = await Promise.all(entries.map(async entry => ({
        ...entry,
        image: await loadImage(entry.image),
        criticality: entry.criticality.toUpperCase()
      })));

      doc.autoTable({
        columns,
        body: data,
        didDrawCell: (data) => {
          if (data.column.dataKey === 'image' && data.cell.raw) {
            const img = data.cell.raw;
            const maxWidth = data.cell.width - 10;
            const maxHeight = data.cell.height - 10;
            const ratio = Math.min(maxWidth / img.width, maxHeight / img.height);
            doc.addImage(
              img,
              'JPEG',
              data.cell.x + 5,
              data.cell.y + 5,
              img.width * ratio,
              img.height * ratio
            );
          }
        },
        styles: { fontSize: 10, cellPadding: 8 },
        columnStyles: {
          image: { cellWidth: 100 }
        },
        margin: { top: 20 },
        pageBreak: 'auto',
        rowPageBreak: 'avoid'
      });

      doc.save('non-conformance-report.pdf');
    }

    async function loadImage(dataUrl) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = dataUrl;
      });
    }

    // Event Listeners
    document.getElementById('entryForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const imageFile = document.getElementById('imageInput').files[0];
      const image = await compressImage(imageFile);
      
      const entry = {
        assetCode: document.getElementById('searchInput').value.trim(),
        nonConformance: document.getElementById('nonConformance').value.trim(),
        criticality: document.getElementById('criticality').value,
        remedial: document.getElementById('remedial').value.trim(),
        image: image
      };

      await saveEntry(entry);
      await loadEntries();
      renderEntries();
      e.target.reset();
    });

    document.getElementById('searchInput').addEventListener('input', 
      debounce(renderEntries, 300)
    );

    document.querySelectorAll('.orientation-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.orientation-btn').forEach(b => 
          b.classList.remove('active'));
        btn.classList.add('active');
        pdfOrientation = btn.dataset.orientation;
      });
    });

    // Utilities
    function debounce(fn, delay) {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn(...args), delay);
      };
    }

    window.deleteItem = async (id) => {
      if (confirm('Delete this entry?')) {
        await deleteEntry(id);
        entries = entries.filter(e => e.id !== id);
        renderEntries();
      }
    };

    // Initialization
    (async () => {
      await initDB();
      await loadEntries();
      renderEntries();
    })();
  </script>
</body>
</html>