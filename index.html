<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Non-conformance Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <!-- Previous CSS remains unchanged -->
  <style>
    /* Add to existing CSS */
    #pdfOrientation {
      margin-bottom: 15px;
    }
    .orientation-selector {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    .orientation-btn {
      padding: 10px 15px;
      border-radius: 8px;
      background: #e3f2fd;
      border: 2px solid #1a73e8;
      cursor: pointer;
    }
    .orientation-btn.active {
      background: #1a73e8;
      color: white;
    }
  </style>
</head>
<body>
  <!-- Add orientation selector -->
  <div class="orientation-selector">
    <button class="orientation-btn active" data-orientation="portrait">Portrait</button>
    <button class="orientation-btn" data-orientation="landscape">Landscape</button>
  </div>

  <!-- Previous HTML remains unchanged -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
  <script>
    // Add orientation state
    let pdfOrientation = 'portrait';

    // Orientation selector logic
    document.querySelectorAll('.orientation-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.orientation-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        pdfOrientation = btn.dataset.orientation;
      });
    });

    // Modified PDF generation
    document.getElementById('generatePdf').addEventListener('click', async () => {
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({
        orientation: pdfOrientation,
        unit: 'pt',
        format: 'letter'
      });

      // Table columns configuration
      const columns = [
        { header: 'Asset Code', dataKey: 'assetCode', cellWidth: 100 },
        { header: 'Photo', dataKey: 'image', cellWidth: 150 },
        { header: 'Non-conformance', dataKey: 'nonConformance', cellWidth: 200 },
        { header: 'Criticality', dataKey: 'criticality', cellWidth: 80 },
        { header: 'Remedial Action', dataKey: 'remedial', cellWidth: 200 }
      ];

      // Process entries for PDF
      const pdfData = await Promise.all(entries.map(async entry => ({
        ...entry,
        criticality: entry.criticality.toUpperCase(),
        image: await createImageCell(doc, entry.image)
      })));

      // Generate PDF table
      doc.autoTable({
        columns,
        body: pdfData,
        styles: { cellPadding: 10, fontSize: 10 },
        columnStyles: {
          image: { cellWidth: 150, minCellHeight: 100 }
        },
        didDrawCell: (data) => {
          if (data.column.dataKey === 'image' && data.cell.raw) {
            const img = data.cell.raw;
            const dim = calculateImageDimensions(img, 140, 90);
            doc.addImage(
              img.img,
              img.format,
              data.cell.x + (data.cell.width - dim.width)/2,
              data.cell.y + 5,
              dim.width,
              dim.height
            );
          }
        },
        margin: { top: 40 },
        startY: 40,
        tableWidth: pdfOrientation === 'portrait' ? 550 : 750,
        theme: 'grid',
        pageBreak: 'auto',
        rowPageBreak: 'avoid'
      });

      doc.save('non-conformance-report.pdf');
    });

    async function createImageCell(doc, imageData) {
      const img = await loadImage(imageData);
      const format = img.src.toLowerCase().includes('png') ? 'PNG' : 'JPEG';
      return { img, format };
    }

    function loadImage(imageData) {
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = imageData;
      });
    }

    function calculateImageDimensions(img, maxWidth, maxHeight) {
      const ratio = Math.min(maxWidth / img.width, maxHeight / img.height);
      return {
        width: img.width * ratio,
        height: img.height * ratio
      };
    }

    // Previous database and UI code remains unchanged
  </script>
</body>
</html>